{"version":3,"sources":["../src/parse.ts"],"names":["parseUrlPath","path","params","sourceFragments","paramsFragments","transforms","stopParsing","split","forEach","fragment","push","transform","keys","Map","Object","entries","filter","x","undefined","map","name","key","some","val","p","get","param","value","parse","validate","length","source","join","ext","target","substring","startsWith","parseBucket","protocol","i","indexOf","Error","endsWith"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2020-present Kriasoft | MIT License (https://git.io/JUgVL)\n */\n\nimport { extname } from \"path\";\nimport { Transform, Param, Params, ParsedOutput } from \"./types\";\n\nexport function parseUrlPath(\n  path: string,\n  params: Readonly<Params>,\n): ParsedOutput {\n  const sourceFragments: string[] = [];\n  const paramsFragments: string[] = [];\n  const transforms: Transform[] = [];\n  let stopParsing = false;\n\n  path.split(\"/\").forEach((fragment) => {\n    if (fragment === \"\") {\n      sourceFragments.push(fragment);\n      return;\n    }\n\n    if (fragment === \"_\") {\n      stopParsing = true;\n      return;\n    }\n\n    if (stopParsing) {\n      sourceFragments.push(fragment);\n      return;\n    }\n\n    const transform: Transform = {};\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    const keys = new Map<string, [key: string, param: Param<any>]>(\n      Object.entries(params as Required<Params>)\n        .filter((x) => x !== undefined)\n        .map(([name, x]) => [x.key, [name, x]]),\n    );\n\n    // Attempts to parse out parameters from the URL path fragment.\n    // E.g. \"w_80,h_16,c_fill\" => [\"w_80\", \"h_60\", \"c_fill\"]\n    fragment.split(\",\").some((x) => {\n      const [key, val] = x.split(\"_\");\n      const p = val === undefined ? undefined : keys.get(key);\n\n      if (p) {\n        const [name, param] = p;\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        const value: any = param.parse(val);\n\n        if (value !== undefined && param.validate(val) !== false) {\n          transform[name as keyof Transform] = value;\n          keys.delete(key);\n          return false;\n        }\n      }\n\n      return true;\n    });\n\n    if (Object.keys(transform).length === 0) {\n      sourceFragments.push(fragment);\n\n      if (!stopParsing && transforms.length > 0) {\n        stopParsing = true;\n      }\n    } else {\n      paramsFragments.push(fragment);\n      transforms.push(transform);\n    }\n  });\n\n  const source = sourceFragments.join(\"/\");\n  const ext = extname(source);\n  const target =\n    transforms.length > 0\n      ? source.substring(0, source.length - ext.length) +\n        \"__\" +\n        paramsFragments.join(\"__\") +\n        ext\n      : undefined;\n\n  return {\n    source: source.startsWith(\"/\") ? source.substring(1) : source,\n    target: target?.startsWith(\"/\") ? target.substring(1) : target,\n    transforms,\n  };\n}\n\n/**\n * Extracts folder name (prefix) from the bucket name.\n *\n * @example\n *   parseBucket(\"gs://s.example.com\")          => [\"gs://s.example.com\", \"\"]\n *   parseBucket(\"gs://s.example.com/\")         => [\"gs://s.example.com\", \"\"]\n *   parseBucket(\"gs://s.example.com/uploads\")  => [\"gs://s.example.com\", \"uploads/\"]\n *   parseBucket(\"gs://s.example.com/uploads/\") => [\"gs://s.example.com\", \"uploads/\"]\n */\nexport function parseBucket(value: string): [bucket: string, prefix: string] {\n  const protocol = ((i) => (i === -1 ? \"gs:\" : value.substring(0, i + 1)))(\n    value.indexOf(\"://\"),\n  );\n\n  if (protocol !== \"gs:\") {\n    throw new Error(\"Only Google Storage buckets are supported at the moment.\");\n  }\n\n  return ((i): [bucket: string, prefix: string] => {\n    return i === -1\n      ? [value, \"\"]\n      : [\n          value.substring(0, i),\n          ((x) => x && (x.endsWith(\"/\") ? x : `${x}/`))(value.substring(i + 1)),\n        ];\n  })(value.indexOf(\"/\", protocol ? protocol.length + 2 : 0));\n}\n"],"file":"parse.js"}